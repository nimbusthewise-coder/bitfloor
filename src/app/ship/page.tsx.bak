"use client";

import { useState, useRef, useEffect } from "react";
import {
  loadSpriteSheet,
  loadFaceSheet,
  bakeIdentitySprites,
  SpriteSheet,
  FaceSheet,
  BakedSprite,
  Identity,
} from "@/lib/sprites";
import {
  PhysicsState,
  GravityDirection,
  ScreenInput,
  updatePhysics,
  getGravityRotation,
  getMoveRightVector,
  PHYSICS,
  PLAYER,
} from "@/lib/physics";
import {
  precomputeMovements,
  createIncrementalSearch,
  stepIncrementalSearch,
  IncrementalSearchState,
  PathStep,
  GravityDir,
  canStand,
} from "@/lib/pathfinding";
import {
  calculateReachableCells,
  findClosestReachable,
  getJumpTrajectories,
  JumpResult,
} from "@/lib/physics-pathfinding";

// Character identities
const nimbus: Identity = {
  id: "nimbus",
  name: "Nimbus",
  faceDNA: [0, 2, 3, 4, 8, 7, 7, 1],
  tints: {
    Suit: "#4ade80",
    Gloves: "#22c55e",
    Boots: "#166534",
    Helmet: "#86efac",
  },
  faceTints: {
    skin: "#ffd5b5",
    hair: "#4a3728",
    background: "#d4fcd4",
  },
  speed: 1,
};

const codex: Identity = {
  id: "codex",
  name: "Codex",
  faceDNA: [0, 1, 2, 3, 4, 5, 0, 0],
  tints: {
    Suit: "#fb923c",
    Gloves: "#f97316",
    Boots: "#c2410c",
    Helmet: "#fdba74",
  },
  faceTints: {
    skin: "#ffd5b5",
    hair: "#8b4513",
    background: "#fde8d4",
  },
  speed: 1.2,
};

// Nim - Target character (pink/magenta)
const nim: Identity = {
  id: "nim",
  name: "Nim",
  faceDNA: [0, 2, 3, 4, 8, 7, 7, 1],
  tints: {
    Suit: "#ff00aa",
    Gloves: "#ff1493",
    Boots: "#c71585",
    Helmet: "#ff69b4",
  },
  faceTints: {
    skin: "#ffe4e1",
    hair: "#ff1493",
    background: "#ffb6c1",
  },
  speed: 1,
};

// Color palette
const COLORS = {
  space: "#000000",
  hull: "#00ffff",
  hullLight: "#ffffff",
  interior: "#3333aa",
  window: "#66ffff",
  floor: "#00cccc",
  console: "#ff0066",
  desk: "#4444cc",
  shaft: "#1a1a4a",    // Vertical shafts (darker, passable)
  hallway: "#2a2a6a",  // Hallway floors
};

const TILE = 32;

// Full ship dimensions (larger than viewport)
const SHIP_W = 32; // 1024px total
const SHIP_H = 16; // 512px total

// Viewport dimensions  
const VIEW_W = 20; // 640px visible
const VIEW_H = 12; // 384px visible

// Room height: 4 tiles vertical space + 1 tile floor = 5 tiles
const ROOM_H = 5;

type CellType = keyof typeof COLORS;

// Room definitions - think architecturally
// Each room is a rectangular area with a position and size
interface Room {
  name: string;
  x: number;
  y: number;
  w: number;
  h: number;
  type: "room" | "hallway" | "shaft" | "hull";
  color?: CellType;
}

const rooms: Room[] = [
  // === UPPER DECK (rows 1-5, 5 tiles: 4 space + 1 floor) ===
  { name: "Engine", x: 1, y: 1, w: 4, h: ROOM_H, type: "room" },
  { name: "Hall-U1", x: 5, y: 1, w: 2, h: ROOM_H, type: "hallway" },
  { name: "Shaft-1", x: 7, y: 1, w: 2, h: ROOM_H * 2, type: "shaft" },
  { name: "Bridge", x: 9, y: 1, w: 6, h: ROOM_H, type: "room" },
  { name: "Hall-U2", x: 15, y: 1, w: 2, h: ROOM_H, type: "hallway" },
  { name: "Shaft-2", x: 17, y: 1, w: 2, h: ROOM_H * 2, type: "shaft" },
  { name: "Quarters", x: 19, y: 1, w: 5, h: ROOM_H, type: "room" },
  { name: "Medical", x: 24, y: 1, w: 5, h: ROOM_H, type: "room" },
  
  // === LOWER DECK (rows 6-10, 5 tiles: 4 space + 1 floor) ===
  { name: "Cargo", x: 1, y: 1 + ROOM_H, w: 4, h: ROOM_H, type: "room" },
  { name: "Hall-L1", x: 5, y: 1 + ROOM_H, w: 2, h: ROOM_H, type: "hallway" },
  { name: "Mess Hall", x: 9, y: 1 + ROOM_H, w: 6, h: ROOM_H, type: "room" },
  { name: "Hall-L2", x: 15, y: 1 + ROOM_H, w: 2, h: ROOM_H, type: "hallway" },
  { name: "Rec Room", x: 19, y: 1 + ROOM_H, w: 5, h: ROOM_H, type: "room" },
  { name: "Storage", x: 24, y: 1 + ROOM_H, w: 5, h: ROOM_H, type: "room" },
];

// Generate the ship grid from room definitions
function generateShipGrid(): CellType[][] {
  // Start with space
  const grid: CellType[][] = Array(SHIP_H).fill(null).map(() => 
    Array(SHIP_W).fill("space" as CellType)
  );
  
  // Draw hull outline (row 0 top, row 11+ bottom)
  for (let x = 0; x < SHIP_W - 3; x++) {
    grid[0][x] = "hull";
    grid[11][x] = "hull";
    grid[12][x] = "hull";
  }
  
  // Side hull
  for (let y = 0; y < 13; y++) {
    grid[y][0] = "hull";
    if (SHIP_W - 4 >= 0) grid[y][SHIP_W - 4] = "hull";
  }
  
  // Draw each room
  for (const room of rooms) {
    for (let y = room.y; y < room.y + room.h && y < SHIP_H; y++) {
      for (let x = room.x; x < room.x + room.w && x < SHIP_W; x++) {
        if (room.type === "shaft") {
          grid[y][x] = "shaft";
        } else if (room.type === "hallway") {
          grid[y][x] = "hallway";
        } else {
          grid[y][x] = "interior";
        }
        
        // Floor on bottom row of room (not for shafts)
        if (y === room.y + room.h - 1 && room.type !== "shaft") {
          grid[y][x] = "floor";
        }
      }
    }
  }
  
  // Add windows in Bridge (row 2)
  for (let x = 10; x < 14; x++) {
    if (grid[2][x] === "interior") grid[2][x] = "window";
  }
  
  // Add windows in Quarters
  for (let x = 20; x < 23; x++) {
    if (grid[2][x] === "interior") grid[2][x] = "window";
  }
  
  // Add consoles in engine room (near floor, row 4)
  if (grid[4][2]) grid[4][2] = "console";
  if (grid[4][3]) grid[4][3] = "console";
  
  // Add consoles in bridge
  if (grid[4][10]) grid[4][10] = "console";
  if (grid[4][13]) grid[4][13] = "console";
  
  // Add desks in quarters
  if (grid[4][21]) grid[4][21] = "desk";
  if (grid[4][22]) grid[4][22] = "desk";
  
  // Add desks in mess hall (lower deck, row 9)
  if (grid[9][11]) grid[9][11] = "desk";
  if (grid[9][12]) grid[9][12] = "desk";
  if (grid[9][13]) grid[9][13] = "desk";
  
  return grid;
}

const shipGrid = generateShipGrid();

// Solid tile types for collision
const SOLID_TILES = ["hull", "hullLight", "floor", "console", "desk"];

// Precompute pathfinding transitions once (ship grid is static)
const movementMap = precomputeMovements(shipGrid, SOLID_TILES);

export default function ShipPage() {
  const [showGrid, setShowGrid] = useState(false);  // Default off for cleaner look
  // CARGO RESCUE: Start camera focused on Cargo bay
  const [viewX, setViewX] = useState(0);
  const [viewY, setViewY] = useState(6);  // Focus on lower deck where Cargo is
  const [cameraEnabled, setCameraEnabled] = useState(true);

  // rAF loop reads/writes these refs; React state is only for rendering/UI.
  const viewXRef = useRef(viewX);
  const viewYRef = useRef(viewY);
  const cameraEnabledRef = useRef(cameraEnabled);

  useEffect(() => { viewXRef.current = viewX; }, [viewX]);
  useEffect(() => { viewYRef.current = viewY; }, [viewY]);
  useEffect(() => { cameraEnabledRef.current = cameraEnabled; }, [cameraEnabled]);

  const containerRef = useRef<HTMLDivElement>(null);
  
  // Spring camera velocity (for smooth ease in-out)
  const cameraVelRef = useRef({ x: 0, y: 0 });
  
  // Nimbus physics state (JP - Player)
  // CARGO RESCUE: Start in Cargo bay with CODEX
  const [charPhysics, setCharPhysics] = useState<PhysicsState>({
    x: 3 * TILE,  // Cargo bay
    y: 11 * TILE - PLAYER.COLLIDER_SIZE - 2,   // Floor at y=11 (Cargo deck) - raised 2px to avoid ground collision
    vx: 0,
    vy: 0,
    gravity: "DOWN",
    grounded: true,
    width: PLAYER.COLLIDER_SIZE,
    height: PLAYER.COLLIDER_SIZE,
    jumpHeld: false,
  });
  const [charDir, setCharDir] = useState<"left" | "right">("right");
  const [charAnim, setCharAnim] = useState<"Idle" | "Run" | "Jump">("Idle");
  const [charFrame, setCharFrame] = useState(0);
  const [displayRotation, setDisplayRotation] = useState(0); // Animated rotation (degrees)
  
  // Codex physics state (AI - learns from JP)
  // CARGO RESCUE: Start in Cargo bay with JP
  const [codexPhysics, setCodexPhysics] = useState<PhysicsState>({
    x: 5 * TILE,  // Cargo bay, next to JP
    y: 11 * TILE - PLAYER.COLLIDER_SIZE - 2,   // Floor at y=11 (Cargo deck) - raised 2px to avoid ground collision
    vx: 0,
    vy: 0,
    gravity: "DOWN",
    grounded: true,
    width: PLAYER.COLLIDER_SIZE,
    height: PLAYER.COLLIDER_SIZE,
    jumpHeld: false,
  });
  const [codexDir, setCodexDir] = useState<"left" | "right">("left");
  const [codexAnim, setCodexAnim] = useState<"Idle" | "Run" | "Jump">("Idle");
  const [codexFrame, setCodexFrame] = useState(0);
  const [codexDisplayRotation, setCodexDisplayRotation] = useState(0); // Animated rotation (degrees)
  
  // AI input state (what the AI "wants" to do this frame)
  const codexInputRef = useRef<ScreenInput>({ up: false, down: false, left: false, right: false, jump: false });
  
  // Refs for the unified rAF loop / AI to access latest physics without stale closures.
  // Note: refs are synced from state via effects, but the rAF loop also writes to them.
  const codexPhysicsRef = useRef(codexPhysics);
  const charPhysicsRef = useRef(charPhysics);
  useEffect(() => { codexPhysicsRef.current = codexPhysics; }, [codexPhysics]);
  useEffect(() => { charPhysicsRef.current = charPhysics; }, [charPhysics]);
  
  // Path visualization (BFS path)
  const [codexPath, setCodexPath] = useState<PathStep[]>([]);
  const codexPathRef = useRef<PathStep[]>([]);
  useEffect(() => { codexPathRef.current = codexPath; }, [codexPath]);

  const [codexPathSegments, setCodexPathSegments] = useState<any[]>([]);
  const [showPaths, setShowPaths] = useState(true);
  
  // Physics-based pathfinding
  const [showPhysicsPaths, setShowPhysicsPaths] = useState(false);
  const [physicsTrajectories, setPhysicsTrajectories] = useState<JumpResult[]>([]);
  const [usePhysicsAI, setUsePhysicsAI] = useState(true); // Start with physics AI enabled

  // Refs for flags used inside the rAF loop (avoids restarting the loop on every render)
  const showPhysicsPathsRef = useRef(showPhysicsPaths);
  const usePhysicsAIRef = useRef(usePhysicsAI);
  useEffect(() => { showPhysicsPathsRef.current = showPhysicsPaths; }, [showPhysicsPaths]);
  useEffect(() => { usePhysicsAIRef.current = usePhysicsAI; }, [usePhysicsAI]);

  // Planned physics paths (for SVG visualization using JumpResult.trajectory)
  const [codexPhysicsPlan, setCodexPhysicsPlan] = useState<JumpResult[]>([]);
  const [nimPhysicsPlan, setNimPhysicsPlan] = useState<JumpResult[]>([]);

  const codexCurrentPathRef = useRef<JumpResult[]>([]); // Full planned path (execution)
  const codexPathProgressRef = useRef(0); // Which jump we're currently executing
  const lastPathCalcTimeRef = useRef(0); // Throttle recalculation
  
  // Nim target character (trapped on Bridge ceiling)
  // CARGO RESCUE: Nim is trapped on Bridge ceiling, waiting for rescue
  const [nimPhysics, setNimPhysics] = useState<PhysicsState>({
    x: 12 * TILE,  // Bridge center
    y: 2 * TILE - PLAYER.COLLIDER_SIZE,   // Ceiling level (y=2 is just below hull at y=1)
    vx: 0,
    vy: 0,
    gravity: "UP",  // Trapped on ceiling!
    grounded: true,
    width: PLAYER.COLLIDER_SIZE,
    height: PLAYER.COLLIDER_SIZE,
    jumpHeld: false,
  });
  const [nimDir, setNimDir] = useState<"left" | "right">("left");
  const [nimAnim, setNimAnim] = useState<"Idle" | "Run" | "Jump">("Idle");
  const [nimFrame, setNimFrame] = useState(0);
  const [nimDisplayRotation, setNimDisplayRotation] = useState(0);
  
  // Nim physics ref (used by rAF loop / AI without stale closures)
  const nimPhysicsRef = useRef(nimPhysics);
  useEffect(() => { nimPhysicsRef.current = nimPhysics; }, [nimPhysics]);
  
  // Recording mode
  const [recording, setRecording] = useState(false);
  const recordingRef = useRef(false); // Ref for latest value in callbacks
  useEffect(() => { recordingRef.current = recording; }, [recording]);
  
  // Replay state
  const [isReplaying, setIsReplaying] = useState(false);
  const isReplayingRef = useRef(isReplaying);
  useEffect(() => { isReplayingRef.current = isReplaying; }, [isReplaying]);

  const replayIntervalRef = useRef<NodeJS.Timeout | null>(null);
  
  const [moveHistory, setMoveHistory] = useState<Array<{char: string, from: {x: number, y: number}, to: {x: number, y: number}, action: string, time: number}>>([]);
  const [gameMessage, setGameMessage] = useState<string>("");
  const recordingStartTime = useRef<number>(0);
  
  // Click-to-move destination
  const [jpDestination, setJpDestination] = useState<{x: number, y: number} | null>(null);
  const [jpPath, setJpPath] = useState<PathStep[]>([]);
  
  // Nim AI pathfinding (click to set destination)
  const [nimDestination, setNimDestination] = useState<{x: number, y: number} | null>(null);
  const nimDestinationRef = useRef<{x: number, y: number} | null>(null);
  useEffect(() => { nimDestinationRef.current = nimDestination; }, [nimDestination]);

  const [nimPath, setNimPath] = useState<PathStep[]>([]);
  const nimCurrentPathRef = useRef<JumpResult[]>([]);
  const nimPathProgressRef = useRef(0);
  const nimLastPathCalcTimeRef = useRef(0);
  const nimInputRef = useRef<ScreenInput>({ up: false, down: false, left: false, right: false, jump: false });
  
  // Nim baked sprites
  const [nimBaked, setNimBaked] = useState<BakedSprite | null>(null);
  
  // Debug: tile position visualization
  const [debugTiles, setDebugTiles] = useState<{
    nimbus: { x: number; y: number; centerX: number; centerY: number; floorX: number; floorY: number } | null;
    codex: { x: number; y: number; centerX: number; centerY: number; floorX: number; floorY: number } | null;
  }>({ nimbus: null, codex: null });
  
  // Debug command panel
  const [commandResults, setCommandResults] = useState<{
    name: string;
    expected: string;
    actual: string;
    passed: boolean | null;
  }[]>([]);
  
  // Sprite loading
  const [nimbusBaked, setNimbusBaked] = useState<BakedSprite | null>(null);
  const [codexBaked, setCodexBaked] = useState<BakedSprite | null>(null);
  const [sheet, setSheet] = useState<SpriteSheet | null>(null);
  const charCanvasRef = useRef<HTMLCanvasElement>(null);
  const codexCanvasRef = useRef<HTMLCanvasElement>(null);
  
  // Load sprites on mount
  useEffect(() => {
    async function load() {
      const [spriteSheet, faceSheet] = await Promise.all([
        loadSpriteSheet(
          "/bitfloor/sprites/character-layers.png",
          "/bitfloor/sprites/character-layers.json"
        ),
        loadFaceSheet("/bitfloor/sprites/face-32.png"),
      ]);
      setSheet(spriteSheet);
      setNimbusBaked(bakeIdentitySprites(spriteSheet, nimbus, faceSheet));
      setCodexBaked(bakeIdentitySprites(spriteSheet, codex, faceSheet));
      setNimBaked(bakeIdentitySprites(spriteSheet, nim, faceSheet));
    }
    load();
  }, []);

  // Scroll handling
  // Keep viewX/viewY refs in sync so the rAF loop doesn't fight manual scrolling.
  const handleScroll = (dx: number, dy: number) => {
    setViewX(x => {
      const nx = Math.max(0, Math.min(SHIP_W - VIEW_W, x + dx));
      viewXRef.current = nx;
      return nx;
    });
    setViewY(y => {
      const ny = Math.max(0, Math.min(SHIP_H - VIEW_H, y + dy));
      viewYRef.current = ny;
      return ny;
    });
  };
  
  // Keyboard input
  const keysRef = useRef(new Set<string>());
  
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      keysRef.current.add(e.key.toLowerCase());
      
      // Arrows = viewport scroll
      if (e.key === "ArrowLeft") handleScroll(-1, 0);
      if (e.key === "ArrowRight") handleScroll(1, 0);
      if (e.key === "ArrowUp") handleScroll(0, -1);
      if (e.key === "ArrowDown") handleScroll(0, 1);
      
      // Prevent space from scrolling page
      if (e.key === " ") e.preventDefault();
    };
    
    const handleKeyUp = (e: KeyboardEvent) => {
      keysRef.current.delete(e.key.toLowerCase());
    };
    
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, []);
  
  // ============================================================
  // UNIFIED REQUESTANIMATIONFRAME GAME LOOP WITH FIXED TIMESTEP
  // ============================================================
  // Replaces the dual setInterval loops (16ms physics + 200ms AI)
  // with a single rAF loop using accumulator pattern for deterministic physics
  // 
  // FIXED TIMESTEP: Physics always runs at 60Hz (16.67ms steps)
  // AI: Runs every 12 frames (~200ms at 60fps)
  // CAMERA: Updated every frame for smooth interpolation
  useEffect(() => {
    // Fixed timestep configuration
    const FIXED_TIMESTEP = 1000 / 60; // ~16.67ms per physics step
    const MAX_ACCUMULATOR = 100; // Prevent spiral of death
    
    // AI runs every ~12 frames (200ms equivalent at 60fps)
    const AI_INTERVAL_FRAMES = 12;
    let frameCount = 0;
    
    // Accumulator for fixed timestep physics
    let accumulator = 0;
    let lastTime: number | null = null;
    let rafId: number;
    
    const gameLoop = (currentTime: number) => {
      // Initialize lastTime on first frame to avoid large initial delta
      if (lastTime === null) {
        lastTime = currentTime;
      }
      
      // Calculate delta time and update accumulator
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      accumulator += deltaTime;
      
      // Clamp accumulator to prevent spiral of death on slow frames
      if (accumulator > MAX_ACCUMULATOR) {
        accumulator = MAX_ACCUMULATOR;
      }
      
      // Get player input once per frame
      const keys = keysRef.current;
      const input: ScreenInput = {
        up: keys.has("w"),
        down: keys.has("s"),
        left: keys.has("a"),
        right: keys.has("d"),
        jump: keys.has(" "),
      };
      
      // Read current physics state from refs (fresh each frame)
      let localCharPhysics = charPhysicsRef.current;
      let localCodexPhysics = codexPhysicsRef.current;
      let localNimPhysics = nimPhysicsRef.current;
      
      // ==========================================================
      // FIXED TIMESTEP PHYSICS: Step physics in discrete intervals
      // This ensures consistent, deterministic physics regardless of
      // frame rate fluctuations or display refresh rate
      // ==========================================================
      let physicsSteps = 0;
      while (accumulator >= FIXED_TIMESTEP) {
        // Store old positions for tile-change detection
        const oldCharX = Math.round(localCharPhysics.x / TILE);
        const oldCharY = Math.round(localCharPhysics.y / TILE);
        const oldCharGravity = localCharPhysics.gravity;
        
        // --- JP (Nimbus) Physics ---
        const newCharState = updatePhysics(localCharPhysics, input, shipGrid, SOLID_TILES);
        localCharPhysics = newCharState;
        charPhysicsRef.current = newCharState;
        
        // Recording: detect tile changes and record moves
        const newCharX = Math.round(newCharState.x / TILE);
        const newCharY = Math.round(newCharState.y / TILE);
        const charPosChanged = newCharX !== oldCharX || newCharY !== oldCharY;
        const charGravityChanged = newCharState.gravity !== oldCharGravity;
        
        if (recordingRef.current && (charPosChanged || charGravityChanged)) {
          let action: string;
          if (!localCharPhysics.grounded && newCharState.grounded && charPosChanged) action = "land";
          else if (localCharPhysics.grounded && !newCharState.grounded) action = "jump";
          else if (charGravityChanged) action = "wall-jump";
          else action = "walk";
          
          setMoveHistory(prev => {
            const lastMove = prev[prev.length - 1];
            if (lastMove && 
                lastMove.from.x === oldCharX && lastMove.from.y === oldCharY &&
                lastMove.to.x === newCharX && lastMove.to.y === newCharY &&
                lastMove.action === action) {
              return prev;
            }
            return [...prev, {
              char: "JP",
              from: { x: oldCharX, y: oldCharY },
              to: { x: newCharX, y: newCharY },
              action,
              time: Date.now() - recordingStartTime.current
            }];
          });
        }
        
        // --- Codex Physics (AI-driven) ---
        const newCodexState = updatePhysics(localCodexPhysics, codexInputRef.current, shipGrid, SOLID_TILES);
        localCodexPhysics = newCodexState;
        codexPhysicsRef.current = newCodexState;
        
        // --- Nim Physics (AI-driven when has destination) ---
        const newNimState = updatePhysics(localNimPhysics, nimInputRef.current, shipGrid, SOLID_TILES);
        localNimPhysics = newNimState;
        nimPhysicsRef.current = newNimState;
        
        accumulator -= FIXED_TIMESTEP;
        physicsSteps++;
        frameCount++;
      }
      
      // ==========================================================
      // VISUAL STATE UPDATES (once per frame, after all physics steps)
      // ==========================================================
      if (physicsSteps > 0) {
        // Update JP (Nimbus) visual state
        const charMoveRightVec = getMoveRightVector(localCharPhysics.gravity);
        const charLateralVel = localCharPhysics.vx * charMoveRightVec.x + localCharPhysics.vy * charMoveRightVec.y;
        if (charLateralVel > 0.3) setCharDir("right");
        else if (charLateralVel < -0.3) setCharDir("left");
        
        const charIsMoving = Math.abs(localCharPhysics.vx) > 0.3 || Math.abs(localCharPhysics.vy) > 0.3;
        if (!localCharPhysics.grounded) setCharAnim("Jump");
        else if (charIsMoving) setCharAnim("Run");
        else setCharAnim("Idle");
        
        // Update Codex visual state
        const codexMoveRightVec = getMoveRightVector(localCodexPhysics.gravity);
        const codexLateralVel = localCodexPhysics.vx * codexMoveRightVec.x + localCodexPhysics.vy * codexMoveRightVec.y;
        if (codexLateralVel > 0.3) setCodexDir("right");
        else if (codexLateralVel < -0.3) setCodexDir("left");
        
        const codexIsMoving = Math.abs(localCodexPhysics.vx) > 0.3 || Math.abs(localCodexPhysics.vy) > 0.3;
        if (!localCodexPhysics.grounded) setCodexAnim("Jump");
        else if (codexIsMoving) setCodexAnim("Run");
        else setCodexAnim("Idle");
        
        // Update Nim visual state
        const nimMoveRightVec = getMoveRightVector(localNimPhysics.gravity);
        const nimLateralVel = localNimPhysics.vx * nimMoveRightVec.x + localNimPhysics.vy * nimMoveRightVec.y;
        if (nimLateralVel > 0.3) setNimDir("right");
        else if (nimLateralVel < -0.3) setNimDir("left");
        
        const nimIsMoving = Math.abs(localNimPhysics.vx) > 0.3 || Math.abs(localNimPhysics.vy) > 0.3;
        if (!localNimPhysics.grounded) setNimAnim("Jump");
        else if (nimIsMoving) setNimAnim("Run");
        else setNimAnim("Idle");
      }
      
      // Apply accumulated physics state to React state (once per frame, not per step)
      // This batches React updates for better performance
      if (physicsSteps > 0) {
        setCharPhysics(localCharPhysics);
        setCodexPhysics(localCodexPhysics);
        setNimPhysics(localNimPhysics);
      }
      
      // ==========================================================
      // SPRING CAMERA UPDATE (runs every frame for smooth interpolation)
      // ==========================================================
      if (cameraEnabled) {
        const targetViewX = Math.max(0, Math.min(
          SHIP_W - VIEW_W, 
          localCharPhysics.x / TILE - VIEW_W / 2
        ));
        const targetViewY = Math.max(0, Math.min(
          SHIP_H - VIEW_H, 
          localCharPhysics.y / TILE - VIEW_H / 2
        ));
        
        // Spring physics: acceleration toward target, with damping
        const stiffness = 0.004;
        const damping = 0.82;
        
        cameraVelRef.current.x += (targetViewX - viewX) * stiffness;
        cameraVelRef.current.x *= damping;
        cameraVelRef.current.y += (targetViewY - viewY) * stiffness;
        cameraVelRef.current.y *= damping;
        
        setViewX(vx => vx + cameraVelRef.current.x);
        setViewY(vy => vy + cameraVelRef.current.y);
      }
      
      // Continue the loop
      rafId = requestAnimationFrame(gameLoop);
    };
    
    // Start the loop
    rafId = requestAnimationFrame(gameLoop);
    
    // Cleanup
    return () => {
      cancelAnimationFrame(rafId);
    };
  }, [cameraEnabled, viewX, viewY]); // Include viewX/viewY for camera spring
  
  // Smooth rotation animation when gravity changes
  useEffect(() => {
    const targetRotation = getGravityRotation(charPhysics.gravity);
    
    const animateRotation = () => {
      setDisplayRotation(current => {
        // Normalize both angles to 0-360
        const normalizedCurrent = ((current % 360) + 360) % 360;
        const normalizedTarget = ((targetRotation % 360) + 360) % 360;
        
        // Calculate shortest path
        let diff = normalizedTarget - normalizedCurrent;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        // If close enough, snap to target
        if (Math.abs(diff) < 2) {
          return normalizedTarget;
        }
        
        // Animate: ~300ms total at 60fps = 18 frames, so move ~5-20 degrees per frame
        // Use easing: faster when far, slower when close
        const speed = Math.max(11, Math.abs(diff) * 0.3);
        const step = Math.sign(diff) * Math.min(speed, Math.abs(diff));
        
        return normalizedCurrent + step;
      });
    };
    
    const rotationInterval = setInterval(animateRotation, 16);
    return () => clearInterval(rotationInterval);
  }, [charPhysics.gravity]);
  
  // Smooth rotation animation for Codex when gravity changes
  useEffect(() => {
    const targetRotation = getGravityRotation(codexPhysics.gravity);
    
    const animateRotation = () => {
      setCodexDisplayRotation(current => {
        const normalizedCurrent = ((current % 360) + 360) % 360;
        const normalizedTarget = ((targetRotation % 360) + 360) % 360;
        
        let diff = normalizedTarget - normalizedCurrent;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        if (Math.abs(diff) < 2) return normalizedTarget;
        
        const speed = Math.max(11, Math.abs(diff) * 0.3);
        const step = Math.sign(diff) * Math.min(speed, Math.abs(diff));
        
        return normalizedCurrent + step;
      });
    };
    
    const rotationInterval = setInterval(animateRotation, 16);
    return () => clearInterval(rotationInterval);
  }, [codexPhysics.gravity]);
  
  // Animation frame update - Nimbus
  useEffect(() => {
    if (!sheet) return;
    const tag = sheet.tags.find(t => t.name === charAnim);
    if (!tag) return;
    
    const interval = setInterval(() => {
      setCharFrame(f => {
        const next = f + 1;
        return next > tag.to ? tag.from : (f < tag.from ? tag.from : next);
      });
    }, 100);
    
    return () => clearInterval(interval);
  }, [charAnim, sheet]);
  
  // Animation frame update - Nim
  useEffect(() => {
    if (!sheet) return;
    const tag = sheet.tags.find(t => t.name === nimAnim);
    if (!tag) return;
    
    const interval = setInterval(() => {
      setNimFrame(f => {
        const next = f + 1;
        return next > tag.to ? tag.from : (f < tag.from ? tag.from : next);
      });
    }, 100);
    
    return () => clearInterval(interval);
  }, [nimAnim, sheet]);
  
  // Calculate physics-based path when CODEX is grounded and needs a new plan
  useEffect(() => {
    // Only recalculate when grounded
    if (!codexPhysics.grounded) return;
    
    const currentPlan = codexCurrentPathRef.current;
    const currentProgress = codexPathProgressRef.current;
    
    // Check if we need a new plan
    const needsNewPlan = currentPlan.length === 0 || currentProgress >= currentPlan.length;
    
    // Check if current plan is stale
    // Get the NEXT jump we should execute
    const nextJump = currentPlan[currentProgress];
    const codexTileX = Math.round(codexPhysics.x / TILE);
    const codexTileY = Math.round(codexPhysics.y / TILE);
    
    // Plan is stale if we moved >3 tiles from expected position or gravity changed
    const pathStale = nextJump && (
      Math.abs(codexTileX - nextJump.start.x) > 3 || 
      Math.abs(codexTileY - nextJump.start.y) > 3 ||
      codexPhysics.gravity !== nextJump.start.gravity
    );
    
    if (!needsNewPlan && !pathStale) return; // Keep current plan
    
    // Throttle recalculation to once per second
    const now = Date.now();
    if (now - lastPathCalcTimeRef.current < 1000) return;
    lastPathCalcTimeRef.current = now;
    
    // Calculate new path
    const nimTileX = Math.round(nimPhysics.x / TILE);
    const nimTileY = Math.round(nimPhysics.y / TILE);
    
    const reachable = calculateReachableCells(
      codexTileX,
      codexTileY,
      codexPhysics.gravity as any,
      shipGrid,
      SOLID_TILES as string[]
    );
    
    // Find best path to Nim
    let bestCell = null;
    let minDist = Infinity;
    
    for (const cell of reachable) {
      const dist = Math.abs(cell.x - nimTileX) + Math.abs(cell.y - nimTileY);
      if (dist < minDist) {
        minDist = dist;
        bestCell = cell;
      }
    }
    
    if (bestCell && bestCell.path.length > 0) {
      codexCurrentPathRef.current = bestCell.path;
      codexPathProgressRef.current = 0;
      
      // Build visualization
      const vizPath = bestCell.path.flatMap((jump: any): PathStep[] => {
        if (!jump.landing) return [];
        return [
          { node: { x: jump.start.x, y: jump.start.y, gravity: jump.start.gravity as GravityDir }, action: 'start' },
          { node: { x: jump.landing.x, y: jump.landing.y, gravity: jump.landing.gravity as GravityDir }, action: 'jump' }
        ];
      });
      setCodexPath(vizPath);
      console.log("[AI] Plan:", bestCell.path.length, "jumps to Nim (", reachable.length, "reachable)");
    }
    
    // Also update trajectory visualization if enabled
    if (showPhysicsPaths) {
      const trajs = getJumpTrajectories(
        codexTileX,
        codexTileY,
        codexPhysics.gravity as any,
        shipGrid,
        SOLID_TILES
      );
      setPhysicsTrajectories(trajs);
    }
  }, [codexPhysics.grounded, codexPhysics.x, codexPhysics.y, codexPhysics.gravity, nimPhysics.x, nimPhysics.y, showPhysicsPaths]);

  // Smooth rotation animation for Nim when gravity changes
  useEffect(() => {
    const targetRotation = getGravityRotation(nimPhysics.gravity);
    
    const animateRotation = () => {
      setNimDisplayRotation(current => {
        const normalizedCurrent = ((current % 360) + 360) % 360;
        const normalizedTarget = ((targetRotation % 360) + 360) % 360;
        
        let diff = normalizedTarget - normalizedCurrent;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        if (Math.abs(diff) < 2) return normalizedTarget;
        
        const speed = Math.max(11, Math.abs(diff) * 0.3);
        const step = Math.sign(diff) * Math.min(speed, Math.abs(diff));
        
        return normalizedCurrent + step;
      });
    };
    
    const rotationInterval = setInterval(animateRotation, 16);
    return () => clearInterval(rotationInterval);
  }, [nimPhysics.gravity]);

  // Animation frame update - Codex
  useEffect(() => {
    if (!sheet) return;
    const tag = sheet.tags.find(t => t.name === codexAnim);
    if (!tag) return;
    
    const interval = setInterval(() => {
      setCodexFrame(f => {
        const next = f + 1;
        return next > tag.to ? tag.from : (f < tag.from ? tag.from : next);
      });
    }, 150); // Walking pace animation
    
    return () => clearInterval(interval);
  }, [codexAnim, sheet]);
  
  // Codex AI - chase player using pathfinding
  const codexPathIndexRef = useRef(0);
  const lastPathTimeRef = useRef(0);
  const codexLastPosRef = useRef({ x: 0, y: 0 });
  const codexStuckCountRef = useRef(0);
  const codexBlockedTransitionsRef = useRef<Set<string>>(new Set());
  const codexSearchRef = useRef<IncrementalSearchState | null>(null);
  const codexSearchMetaRef = useRef<{ startKey: string; goalKey: string } | null>(null);
  
  useEffect(() => {
    const aiInterval = setInterval(() => {
      // Skip AI during replay
      if (isReplaying) return;
      
      // Read latest physics from refs (avoids stale closure)
      const codexPhysics = codexPhysicsRef.current;
      const charPhysics = charPhysicsRef.current;
      
      // Safety: if Codex goes off the map, reset to near player
      const BOUNDS_MARGIN = TILE * 2;
      const outOfBounds = 
        codexPhysics.x < -BOUNDS_MARGIN || 
        codexPhysics.x > SHIP_W * TILE + BOUNDS_MARGIN ||
        codexPhysics.y < -BOUNDS_MARGIN || 
        codexPhysics.y > SHIP_H * TILE + BOUNDS_MARGIN;
      
      if (outOfBounds) {
        console.log("[AI] Codex out of bounds! Resetting...");
        // Reset Codex to spawn position
        setCodexPhysics({
          x: 13 * TILE,
          y: 5 * TILE - PLAYER.COLLIDER_SIZE,
          vx: 0,
          vy: 0,
          gravity: "DOWN",
          grounded: true,
          width: PLAYER.COLLIDER_SIZE,
          height: PLAYER.COLLIDER_SIZE,
          jumpHeld: false,
        });
        setCodexPath([]);
        codexPathIndexRef.current = 0;
        return; // Skip this frame
      }
      
      // --- Path search (incremental, budgeted per AI tick) ---
      // Get standing tile position - MUST account for current gravity!
      const getStandingTile = (physics: PhysicsState) => {
        const centerX = physics.x + physics.width / 2;
        const centerY = physics.y + physics.height / 2;

        switch (physics.gravity) {
          case "DOWN":
            return { x: Math.floor(centerX / TILE), y: Math.floor((physics.y + physics.height - 1) / TILE) };
          case "UP":
            return { x: Math.floor(centerX / TILE), y: Math.floor(physics.y / TILE) };
          case "LEFT":
            return { x: Math.floor(physics.x / TILE), y: Math.floor(centerY / TILE) };
          case "RIGHT":
            return { x: Math.floor((physics.x + physics.width - 1) / TILE), y: Math.floor(centerY / TILE) };
        }
      };

      const codexTile = getStandingTile(codexPhysics);
      const playerTile = getStandingTile(charPhysics); // For debug visualization
      // CARGO RESCUE: CODEX targets Nim (the pink character on Bridge ceiling)
      const targetTile = getStandingTile(nimPhysics);

      // Update debug visualization
      const getFloorOffset = (gravity: string) => {
        switch (gravity) {
          case "DOWN": return { dx: 0, dy: 1 };
          case "UP": return { dx: 0, dy: -1 };
          case "LEFT": return { dx: -1, dy: 0 };
          case "RIGHT": return { dx: 1, dy: 0 };
          default: return { dx: 0, dy: 1 };
        }
      };
      const nimbusFloor = getFloorOffset(charPhysics.gravity);
      const codexFloor = getFloorOffset(codexPhysics.gravity);

      setDebugTiles({
        nimbus: {
          ...playerTile,
          centerX: charPhysics.x + charPhysics.width / 2,
          centerY: charPhysics.y + charPhysics.height / 2,
          floorX: playerTile.x + nimbusFloor.dx,
          floorY: playerTile.y + nimbusFloor.dy,
        },
        codex: {
          ...codexTile,
          centerX: codexPhysics.x + codexPhysics.width / 2,
          centerY: codexPhysics.y + codexPhysics.height / 2,
          floorX: codexTile.x + codexFloor.dx,
          floorY: codexTile.y + codexFloor.dy,
        },
      });

      // Only search if CODEX is grounded and target is valid
      if (codexPhysics.grounded) {
        const startNode = { x: codexTile.x, y: codexTile.y, gravity: codexPhysics.gravity as GravityDir };
        // CARGO RESCUE: CODEX targets Nim (not JP)
        const goalNode = { x: targetTile.x, y: targetTile.y };

        const startKey = `${startNode.x},${startNode.y},${startNode.gravity}`;
        const goalKey = `${goalNode.x},${goalNode.y}`;

        // Use physics-based AI or BFS
        if (usePhysicsAI) {
          // Path is calculated in useEffect, just execute the current plan
          // No need to recalculate here - useEffect handles that
        } else {
          // BFS-based pathfinding
          // (Re)start incremental search when start/goal tile changes
          if (!codexSearchRef.current || !codexSearchMetaRef.current ||
              codexSearchMetaRef.current.startKey !== startKey ||
              codexSearchMetaRef.current.goalKey !== goalKey) {
            codexSearchRef.current = createIncrementalSearch(startNode, goalNode);
            codexSearchMetaRef.current = { startKey, goalKey };
          }

          // Spend a fixed budget each tick.
          const result = stepIncrementalSearch(
            codexSearchRef.current,
            shipGrid,
            SOLID_TILES as string[],
            movementMap,
            codexBlockedTransitionsRef.current,
            100
          );

          if (result.status === "found") {
            setCodexPath(result.path);
            setCodexPathSegments(result.segments);
            codexPathIndexRef.current = 1;
          } else if (result.status === "not_found") {
            setCodexPath([]);
            setCodexPathSegments([]);
            codexPathIndexRef.current = 0;
          }
        }
      }
      
      // AI decision: look at current path step and decide input
      const input: ScreenInput = { up: false, down: false, left: false, right: false, jump: false };
      
      // Calculate direct distance to target (Nim)
      const codexCenterX = codexPhysics.x + codexPhysics.width / 2;
      const codexCenterY = codexPhysics.y + codexPhysics.height / 2;
      const targetCenterX = nimPhysics.x + nimPhysics.width / 2;
      const targetCenterY = nimPhysics.y + nimPhysics.height / 2;
      const directDx = targetCenterX - codexCenterX;
      const directDy = targetCenterY - codexCenterY;
      const directDist = Math.sqrt(directDx * directDx + directDy * directDy);
      
      // Stop if very close to target
      const STOP_DISTANCE = TILE * 1.5;
      
      if (directDist <= STOP_DISTANCE && codexPath.length > 0) {
        codexPathIndexRef.current = codexPath.length;
      }
      
      // PHYSICS-BASED AI MODE: Execute pre-calculated jump trajectory
      const currentPlan = codexCurrentPathRef.current;
      const progress = codexPathProgressRef.current;
      const currentJumpIndex = Math.floor(progress);
      const isMidJump = progress % 1 !== 0; // Has decimal part = mid-jump
      const isWalking = progress % 1 === 0.25; // 0.25 = walking state
      
      if (usePhysicsAI && currentPlan.length > 0 && currentJumpIndex < currentPlan.length && directDist > STOP_DISTANCE) {
        const action = currentPlan[currentJumpIndex];
        const grav = codexPhysics.gravity;
        
        // Get target position for this action
        const targetX = action.landing?.x ?? action.start.x;
        const targetY = action.landing?.y ?? action.start.y;
        const targetPixelX = targetX * TILE + TILE / 2;
        const targetPixelY = targetY * TILE + TILE / 2;
        
        if (isMidJump && codexPhysics.grounded) {
          // Just landed from a jump, advance to next action
          codexPathProgressRef.current = currentJumpIndex + 1;
        } else if (isWalking) {
          // Continue walking until we reach the target
          const distToTarget = Math.abs(codexCenterX - targetPixelX) + Math.abs(codexCenterY - targetPixelY);
          if (distToTarget < TILE * 1.0) {
            // Reached target - SNAP to exact position to prevent overshoot
            newState.x = targetPixelX - state.width / 2;
            newState.y = targetPixelY - state.height / 2;
            newState.vx = 0;
            newState.vy = 0;
            codexPathProgressRef.current = currentJumpIndex + 1;
          } else {
            // Continue walking in the same direction
            if (action.action === "walk-left") {
              if (grav === "DOWN") input.left = true;
              else if (grav === "UP") input.right = true;
              else if (grav === "LEFT") input.up = true;
              else if (grav === "RIGHT") input.down = true;
            } else if (action.action === "walk-right") {
              if (grav === "DOWN") input.right = true;
              else if (grav === "UP") input.left = true;
              else if (grav === "LEFT") input.down = true;
              else if (grav === "RIGHT") input.up = true;
            }
          }
        } else if (!isMidJump && !isWalking && codexPhysics.grounded) {
          // Ready to execute next action
          
          // Handle walking actions
          if (action.action === "walk-left") {
            if (grav === "DOWN") input.left = true;
            else if (grav === "UP") input.right = true;
            else if (grav === "LEFT") input.up = true;
            else if (grav === "RIGHT") input.down = true;
            // Mark as walking (0.25 = walking state)
            codexPathProgressRef.current = currentJumpIndex + 0.25;
          } else if (action.action === "walk-right") {
            if (grav === "DOWN") input.right = true;
            else if (grav === "UP") input.left = true;
            else if (grav === "LEFT") input.down = true;
            else if (grav === "RIGHT") input.up = true;
            // Mark as walking
            codexPathProgressRef.current = currentJumpIndex + 0.25;
          } else if (action.action === "jump-left") {
            // Gravity-left means different screen directions based on gravity
            if (grav === "DOWN") input.left = true;
            else if (grav === "UP") input.right = true;
            else if (grav === "LEFT") input.up = true;
            else if (grav === "RIGHT") input.down = true;
            input.jump = true;
            // Mark that we've initiated this jump (will advance when we land)
            codexPathProgressRef.current = currentJumpIndex + 0.5;
          } else if (action.action === "jump-right") {
            if (grav === "DOWN") input.right = true;
            else if (grav === "UP") input.left = true;
            else if (grav === "LEFT") input.down = true;
            else if (grav === "RIGHT") input.up = true;
            input.jump = true;
            codexPathProgressRef.current = currentJumpIndex + 0.5;
          } else {
            input.jump = true; // straight jump
            codexPathProgressRef.current = currentJumpIndex + 0.5;
          }
        }
        
      } else if (directDist > STOP_DISTANCE) {
        // BFS FALLBACK MODE
        let targetX: number, targetY: number;
        let shouldJump = false;
        let needsGravityTransition = false;
        
        if (codexPath.length > 0 && codexPathIndexRef.current < codexPath.length) {
          const targetStep = codexPath[codexPathIndexRef.current];
          targetX = targetStep.node.x * TILE + TILE / 2;
          targetY = targetStep.node.y * TILE + TILE / 2;
          shouldJump = targetStep.action === "jump" || targetStep.action === "fall";
          
          const dx = targetX - codexCenterX;
          const dy = targetY - codexCenterY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (targetStep.node.gravity !== codexPhysics.gravity && dist < TILE * 2) {
            needsGravityTransition = true;
          }
          
          if (dist < TILE / 2) {
            codexPathIndexRef.current++;
          }
        } else {
          targetX = targetCenterX;
          targetY = targetCenterY;
        }
        
        const dx = targetX - codexCenterX;
        const dy = targetY - codexCenterY;
        
        // Screen-relative walking
        if (codexPhysics.gravity === "DOWN" || codexPhysics.gravity === "UP") {
          if (dx > 4) input.right = true;
          else if (dx < -4) input.left = true;
        } else {
          if (dy > 4) input.down = true;
          else if (dy < -4) input.up = true;
        }
        
        // Stuck detection
        const lastPos = codexLastPosRef.current;
        const posDelta = Math.abs(codexPhysics.x - lastPos.x) + Math.abs(codexPhysics.y - lastPos.y);
        const isTryingToMove = input.left || input.right || input.up || input.down;
        
        if (isTryingToMove && posDelta < 1 && codexPhysics.grounded) {
          codexStuckCountRef.current++;
        } else {
          codexStuckCountRef.current = 0;
        }
        codexLastPosRef.current = { x: codexPhysics.x, y: codexPhysics.y };
        
        // Auto-jump if stuck or needs transition (legacy BFS mode only)
        const isStuck = codexStuckCountRef.current > 10;
        if ((shouldJump || isStuck || needsGravityTransition) && codexPhysics.grounded) {
          const nearEdge = codexPhysics.x < TILE * 2 || codexPhysics.x > (SHIP_W - 2) * TILE ||
                           codexPhysics.y < TILE * 2 || codexPhysics.y > (SHIP_H - 2) * TILE;
          if (!nearEdge) input.jump = true;
          // Debug logs only when recording
          if (recording) {
            if (isStuck) console.log("[AI] Stuck! Jumping");
            if (needsGravityTransition) console.log("[AI] Gravity transition");
          }
        }
      }
      
      // Apply AI input
      codexInputRef.current = input;
      
      // === NIM AI: Follow player-clicked destination ===
      const nimPhys = nimPhysicsRef.current;
      const nimCenterX = nimPhys.x + nimPhys.width / 2;
      const nimCenterY = nimPhys.y + nimPhys.height / 2;
      const nimInput: ScreenInput = { up: false, down: false, left: false, right: false, jump: false };
      
      if (nimDestination) {
        // Recalculate path periodically or if path is empty
        const now = Date.now();
        const needsRecalc = nimCurrentPathRef.current.length === 0 || 
                           (nimPhys.grounded && now % 1000 < 200); // Recalc roughly every second when grounded
        
        if (needsRecalc) {
          const nimTileX = Math.round(nimPhys.x / TILE);
          const nimTileY = Math.round(nimPhys.y / TILE);
          
          const reachable = calculateReachableCells(
            nimTileX,
            nimTileY,
            nimPhys.gravity as any,
            shipGrid,
            SOLID_TILES as string[]
          );
          
          // Find best path to destination
          let bestCell = null;
          let minDist = Infinity;
          for (const cell of reachable) {
            const dist = Math.abs(cell.x - nimDestination.x) + Math.abs(cell.y - nimDestination.y);
            if (dist < minDist) {
              minDist = dist;
              bestCell = cell;
            }
          }
          
          if (bestCell && bestCell.path.length > 0) {
            // Only update path if we found a better one or current is empty
            if (nimCurrentPathRef.current.length === 0 || minDist < 3) {
              nimCurrentPathRef.current = bestCell.path;
              nimPathProgressRef.current = 0;
              console.log(`[Nim AI] Recalculated path: ${bestCell.path.length} actions, dist to dest: ${minDist}`);
            }
          }
        }
        
        // Execute current path
        if (nimCurrentPathRef.current.length > 0) {
          const nimProgress = nimPathProgressRef.current;
          const nimJumpIndex = Math.floor(nimProgress);
          const nimIsMidJump = nimProgress % 1 !== 0 && nimProgress % 1 !== 0.25;
          const nimIsWalking = nimProgress % 1 === 0.25;
          
          if (nimJumpIndex < nimCurrentPathRef.current.length) {
            const nimAction = nimCurrentPathRef.current[nimJumpIndex];
            const nimGrav = nimPhys.gravity;
            
            // Check if gravity matches what we expected for this action
            if (nimAction.start.gravity !== nimGrav && nimPhys.grounded) {
              console.log(`[Nim AI] Gravity mismatch! Expected ${nimAction.start.gravity}, got ${nimGrav}. Recalculating...`);
              nimCurrentPathRef.current = []; // Force recalc
            } else {
              const nimTargetX = nimAction.landing?.x ?? nimAction.start.x;
              const nimTargetY = nimAction.landing?.y ?? nimAction.start.y;
              const nimTargetPixelX = nimTargetX * TILE + TILE / 2;
              const nimTargetPixelY = nimTargetY * TILE + TILE / 2;
              
              if (nimIsMidJump && nimPhys.grounded) {
                console.log(`[Nim AI] Landed from jump ${nimJumpIndex}, advancing`);
                nimPathProgressRef.current = nimJumpIndex + 1;
              } else if (nimIsWalking) {
                const distToTarget = Math.abs(nimCenterX - nimTargetPixelX) + Math.abs(nimCenterY - nimTargetPixelY);
                if (distToTarget < TILE * 1.0) {
                  // Reached target - SNAP to exact position to prevent overshoot
                  newNimState.x = nimTargetPixelX - newNimState.width / 2;
                  newNimState.y = nimTargetPixelY - newNimState.height / 2;
                  newNimState.vx = 0;
                  newNimState.vy = 0;
                  nimPathProgressRef.current = nimJumpIndex + 1;
                } else {
                  if (nimAction.action === "walk-left") {
                    if (nimGrav === "DOWN") nimInput.left = true;
                    else if (nimGrav === "UP") nimInput.right = true;
                    else if (nimGrav === "LEFT") nimInput.up = true;
                    else if (nimGrav === "RIGHT") nimInput.down = true;
                  } else if (nimAction.action === "walk-right") {
                    if (nimGrav === "DOWN") nimInput.right = true;
                    else if (nimGrav === "UP") nimInput.left = true;
                    else if (nimGrav === "LEFT") nimInput.down = true;
                    else if (nimGrav === "RIGHT") nimInput.up = true;
                  }
                }
              } else if (!nimIsMidJump && !nimIsWalking && nimPhys.grounded) {
                if (nimAction.action === "walk-left") {
                  if (nimGrav === "DOWN") nimInput.left = true;
                  else if (nimGrav === "UP") nimInput.right = true;
                  else if (nimGrav === "LEFT") nimInput.up = true;
                  else if (nimGrav === "RIGHT") nimInput.down = true;
                  nimPathProgressRef.current = nimJumpIndex + 0.25;
                } else if (nimAction.action === "walk-right") {
                  if (nimGrav === "DOWN") nimInput.right = true;
                  else if (nimGrav === "UP") nimInput.left = true;
                  else if (nimGrav === "LEFT") nimInput.down = true;
                  else if (nimGrav === "RIGHT") nimInput.up = true;
                  nimPathProgressRef.current = nimJumpIndex + 0.25;
                } else if (nimAction.action === "jump-left") {
                  if (nimGrav === "DOWN") nimInput.left = true;
                  else if (nimGrav === "UP") nimInput.right = true;
                  else if (nimGrav === "LEFT") nimInput.up = true;
                  else if (nimGrav === "RIGHT") nimInput.down = true;
                  nimInput.jump = true;
                  nimPathProgressRef.current = nimJumpIndex + 0.5;
                } else if (nimAction.action === "jump-right") {
                  if (nimGrav === "DOWN") nimInput.right = true;
                  else if (nimGrav === "UP") nimInput.left = true;
                  else if (nimGrav === "LEFT") nimInput.down = true;
                  else if (nimGrav === "RIGHT") nimInput.up = true;
                  nimInput.jump = true;
                  nimPathProgressRef.current = nimJumpIndex + 0.5;
                } else {
                  nimInput.jump = true;
                  nimPathProgressRef.current = nimJumpIndex + 0.5;
                }
              }
            }
          } else {
            // Reached destination
            setNimDestination(null);
            nimCurrentPathRef.current = [];
          }
        }
      }
      
      nimInputRef.current = nimInput;
      
    }, 200); // AI runs at 5Hz (was 20Hz) for performance
    
    return () => clearInterval(aiInterval);
  }, [isReplaying, nimDestination]); // Re-create interval when replay state or nimDestination changes
  
  // Draw Nimbus
  useEffect(() => {
    if (!nimbusBaked || !charCanvasRef.current) return;
    const ctx = charCanvasRef.current.getContext("2d");
    if (!ctx) return;
    
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, 48, 48);
    
    ctx.save();
    ctx.translate(24, 24);  // Canvas center
    
    // Smooth animated rotation around collision center
    ctx.rotate(displayRotation * Math.PI / 180);
    
    // Flip for direction
    if (charDir === "left") {
      ctx.scale(-1, 1);
    }
    
    // Draw sprite centered at the rotation point
    ctx.drawImage(
      nimbusBaked.canvas,
      charFrame * 48, 0, 48, 48,
      -24, -24, 48, 48
    );
    ctx.restore();
  }, [nimbusBaked, charFrame, charDir, displayRotation]);
  
  // Draw Codex
  useEffect(() => {
    if (!codexBaked || !codexCanvasRef.current) return;
    const ctx = codexCanvasRef.current.getContext("2d");
    if (!ctx) return;
    
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, 48, 48);
    
    ctx.save();
    ctx.translate(24, 24);  // Canvas center
    
    // Smooth animated rotation around collision center
    ctx.rotate(codexDisplayRotation * Math.PI / 180);
    
    // Flip for direction
    if (codexDir === "left") {
      ctx.scale(-1, 1);
    }
    
    // Draw sprite centered at the rotation point
    ctx.drawImage(
      codexBaked.canvas,
      codexFrame * 48, 0, 48, 48,
      -24, -24, 48, 48
    );
    ctx.restore();
  }, [codexBaked, codexFrame, codexDir, codexDisplayRotation]);

  // Calculate character positions relative to viewport
  // Sprite is 4848, collision is 3244
  // We need to align sprite "feet" with collision "floor edge" for each gravity
  // The offset changes based on gravity orientation since collision box doesn't rotate
  
  // Offset from collision top-left to where 4848 sprite should be drawn
  // to align the visual feet with collision floor-side
  const getSpriteOffset = (gravity: GravityDirection): { x: number; y: number } => {
    const spriteW = 48, spriteH = 48;
    const collW = PLAYER.COLLIDER_SIZE;
    const collH = PLAYER.COLLIDER_SIZE;
    const extraW = (spriteW - collW) / 2;

    switch (gravity) {
      case "DOWN":  // Feet at bottom - align sprite bottom with collision bottom
        return { x: -extraW, y: -(spriteH - collH) };
      case "UP":    // Feet at top - align sprite top with collision top
        return { x: -extraW, y: 0 };
      case "LEFT":  // Feet at left - align sprite left with collision left
        return { x: 0, y: -extraW };
      case "RIGHT": // Feet at right - align sprite right with collision right
        return { x: -(spriteW - collW), y: -extraW };
    }
  };
  
  const spriteOffset = getSpriteOffset(charPhysics.gravity);
  // Snap character positions to integer pixels for crisp rendering
  const charScreenX = Math.round(charPhysics.x - viewX * TILE + spriteOffset.x);
  const charScreenY = Math.round(charPhysics.y - viewY * TILE + spriteOffset.y);
  const charVisible = charScreenX > -48 && charScreenX < VIEW_W * TILE &&
                      charScreenY > -48 && charScreenY < VIEW_H * TILE;
  
  const codexSpriteOffset = getSpriteOffset(codexPhysics.gravity);
  const codexScreenX = Math.round(codexPhysics.x - viewX * TILE + codexSpriteOffset.x);
  const codexScreenY = Math.round(codexPhysics.y - viewY * TILE + codexSpriteOffset.y);
  const codexVisible = codexScreenX > -48 && codexScreenX < VIEW_W * TILE &&
                       codexScreenY > -48 && codexScreenY < VIEW_H * TILE;

  // Get visible portion of grid (use integer coords for slicing, +1 for partial tiles)
  const viewXInt = Math.floor(viewX);
  const viewYInt = Math.floor(viewY);
  
  const visibleGrid = shipGrid
    .slice(viewYInt, viewYInt + VIEW_H + 1)
    .map(row => row.slice(viewXInt, viewXInt + VIEW_W + 1));

  // Get room labels that are visible
  const visibleRooms = rooms.filter(room => 
    room.x + room.w > viewXInt && room.x < viewXInt + VIEW_W + 1 &&
    room.y + room.h > viewYInt && room.y < viewYInt + VIEW_H + 1
  );

  return (
    <div style={{
      minHeight: "100vh",
      background: "#0a0a0f",
      padding: 20,
      fontFamily: "'Press Start 2P', monospace",
      color: "#fff",
      fontSize: 10,
    }}>
      <h1 style={{ fontSize: 14, color: "#0f0", marginBottom: 20 }}>
        BITSHIP - DECK VIEW
      </h1>

      {/* Controls */}
      <div style={{ marginBottom: 20, display: "flex", gap: 10, flexWrap: "wrap" }}>
        <button
          onClick={() => setShowGrid(g => !g)}
          style={{
            padding: "4px 8px",
            background: showGrid ? "#0f0" : "#333",
            color: showGrid ? "#000" : "#fff",
            border: "1px solid #0f0",
            cursor: "pointer",
          }}
        >
          GRID {showGrid ? "ON" : "OFF"}
        </button>
        <button
          onClick={() => setCameraEnabled(c => !c)}
          style={{
            padding: "4px 8px",
            background: cameraEnabled ? "#0ff" : "#333",
            color: cameraEnabled ? "#000" : "#fff",
            border: "1px solid #0ff",
            cursor: "pointer",
          }}
        >
          CAM {cameraEnabled ? "ON" : "OFF"}
        </button>
        <button
          onClick={() => setShowPaths(p => !p)}
          style={{
            padding: "4px 8px",
            background: showPaths ? "#fb923c" : "#333",
            color: showPaths ? "#000" : "#fff",
            border: "1px solid #fb923c",
            cursor: "pointer",
          }}
        >
          PATH {showPaths ? "ON" : "OFF"}
        </button>
        <button
          onClick={() => setShowPhysicsPaths(p => !p)}
          style={{
            padding: "4px 8px",
            background: showPhysicsPaths ? "#0f0" : "#333",
            color: showPhysicsPaths ? "#000" : "#0f0",
            border: "1px solid #0f0",
            cursor: "pointer",
          }}
        >
          PHYS {showPhysicsPaths ? "ON" : "OFF"}
        </button>
        <button
          onClick={() => setUsePhysicsAI(p => !p)}
          style={{
            padding: "4px 8px",
            background: usePhysicsAI ? "#f0f" : "#333",
            color: usePhysicsAI ? "#000" : "#f0f",
            border: "1px solid #f0f",
            cursor: "pointer",
          }}
        >
          AI: {usePhysicsAI ? "PHYS" : "BFS"}
        </button>
        <button
          onClick={() => {
            if (recording) {
              setRecording(false);
              setGameMessage(" Recording stopped");
            } else {
              setRecording(true);
              setMoveHistory([]);
              recordingStartTime.current = Date.now();
              setGameMessage(" RECORDING - Move JP to catch Nim!");
            }
          }}
          style={{
            padding: "4px 8px",
            background: recording ? "#f00" : "#333",
            color: recording ? "#fff" : "#f00",
            border: "1px solid #f00",
            cursor: "pointer",
          }}
        >
          {recording ? " STOP" : " RECORD"}
        </button>
        <button
          onClick={() => {
            // Cancel any existing replay
            if (replayIntervalRef.current) {
              clearInterval(replayIntervalRef.current);
              replayIntervalRef.current = null;
            }
            
            if (isReplaying) {
              setIsReplaying(false);
              setGameMessage(" Replay stopped");
              return;
            }
            
            // Replay: Make CODEX follow recorded path
            if (moveHistory.length === 0) {
              setGameMessage(" No moves recorded yet!");
              return;
            }
            
            // Reset CODEX to start position
            const firstMove = moveHistory[0];
            setCodexPhysics({
              x: firstMove.from.x * TILE,
              y: firstMove.from.y * TILE - PLAYER.COLLIDER_SIZE,
              vx: 0, vy: 0, gravity: "DOWN", grounded: true,
              width: PLAYER.COLLIDER_SIZE, height: PLAYER.COLLIDER_SIZE, jumpHeld: false
            });
            
            // Replay each move
            setIsReplaying(true);
            setGameMessage(" REPLAYING JP's path...");
            let moveIndex = 0;
            
            // Replay with smooth interpolation
            const STEPS_PER_MOVE = 5; // Interpolate each move into 5 steps
            const STEP_DURATION = 30; // 30ms per step = 150ms total per move
            let stepIndex = 0;
            
            replayIntervalRef.current = setInterval(() => {
              if (moveIndex >= moveHistory.length) {
                clearInterval(replayIntervalRef.current!);
                replayIntervalRef.current = null;
                setIsReplaying(false);
                setGameMessage(" Replay complete!");
                return;
              }
              
              const move = moveHistory[moveIndex];
              const progress = stepIndex / STEPS_PER_MOVE;
              
              // Linear interpolation between from and to
              const interpX = move.from.x + (move.to.x - move.from.x) * progress;
              const interpY = move.from.y + (move.to.y - move.from.y) * progress;
              
              setCodexPhysics(prev => ({
                ...prev,
                x: interpX * TILE,
                y: interpY * TILE - PLAYER.COLLIDER_SIZE,
                gravity: "DOWN", 
                grounded: progress > 0.8 || move.action !== "jump", // Show jump mid-air
              }));
              
              stepIndex++;
              if (stepIndex >= STEPS_PER_MOVE) {
                stepIndex = 0;
                moveIndex++;
              }
            }, STEP_DURATION);
          }}
          style={{
            padding: "4px 8px",
            background: isReplaying ? "#f00" : moveHistory.length > 0 ? "#0f0" : "#333",
            color: isReplaying || moveHistory.length > 0 ? "#000" : "#0f0",
            border: "1px solid #0f0",
            cursor: moveHistory.length > 0 ? "pointer" : "not-allowed",
          }}
          disabled={moveHistory.length === 0 && !isReplaying}
        >
          {isReplaying ? " STOP" : ` REPLAY (${moveHistory.length})`}
        </button>
        <button
          onClick={() => {
            setNimDestination(null);
            nimCurrentPathRef.current = [];
          }}
          style={{
            padding: "4px 8px",
            background: nimDestination ? "#f0f" : "#333",
            color: nimDestination ? "#000" : "#f0f",
            border: "1px solid #f0f",
            cursor: "pointer",
          }}
        >
          {nimDestination ? `Nim  (${nimDestination.x},${nimDestination.y})` : "Click to set Nim DEST"}
        </button>
        <span style={{ color: "#666", alignSelf: "center" }}>
          WASD = move JP | Click = set Nim DEST | Space = jump
        </span>
        <span style={{ 
          color: charPhysics.grounded ? "#4ade80" : "#ff6b6b", 
          alignSelf: "center",
          marginLeft: "auto",
          whiteSpace: "nowrap",
        }}>
          {charPhysics.gravity} | {charPhysics.grounded ? "" : ""}
        </span>
      </div>
      
      {gameMessage && (
        <div style={{
          marginBottom: 10,
          padding: "8px 12px",
          background: recording ? "#f001" : "#0f01",
          border: `1px solid ${recording ? "#f00" : "#0f0"}`,
          color: recording ? "#f00" : "#0f0",
          fontSize: 10,
        }}>
          {gameMessage}
        </div>
      )}

      {/* Move History Panel */}
      {moveHistory.length > 0 && (
        <div style={{
          marginBottom: 10,
          padding: "8px 12px",
          background: "#1a1a2e",
          border: "1px solid #0ff",
          fontSize: 9,
          maxHeight: 120,
          overflow: "auto",
        }}>
          <div style={{ color: "#0ff", marginBottom: 4 }}> MOVE HISTORY ({moveHistory.length} moves)</div>
          <div style={{ display: "flex", flexDirection: "column", gap: 2 }}>
            {moveHistory.slice(-10).map((move, i) => (
              <div key={i} style={{ display: "flex", gap: 8, color: "#ccc" }}>
                <span style={{ color: "#4ade80" }}>{move.action}</span>
                <span>({move.from.x},{move.from.y})  ({move.to.x},{move.to.y})</span>
                <span style={{ color: "#666" }}>{move.time}ms</span>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Ship viewport */}
      <div 
        ref={containerRef}
        style={{
          position: "relative",
          width: VIEW_W * TILE,
          height: VIEW_H * TILE,
          background: COLORS.space,
          border: "2px solid #00ffff",
          overflow: "hidden",
          cursor: "crosshair",
        }}
        tabIndex={0}
        onClick={(e) => {
          // Click to set NIM destination (pink character)
          const rect = e.currentTarget.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const clickY = e.clientY - rect.top;
          
          // Convert to ship coordinates
          const shipX = viewX * TILE + clickX;
          const shipY = viewY * TILE + clickY;
          
          const tileX = Math.floor(shipX / TILE);
          const tileY = Math.floor(shipY / TILE);
          
          if (tileX >= 0 && tileX < SHIP_W && tileY >= 0 && tileY < SHIP_H) {
            setNimDestination({ x: tileX, y: tileY });
            
            // Calculate physics-based path for Nim
            const reachable = calculateReachableCells(
              Math.round(nimPhysics.x / TILE),
              Math.round(nimPhysics.y / TILE),
              nimPhysics.gravity as any,
              shipGrid,
              SOLID_TILES as string[]
            );
            
            // Find best path to clicked destination
            let bestCell = null;
            let minDist = Infinity;
            for (const cell of reachable) {
              const dist = Math.abs(cell.x - tileX) + Math.abs(cell.y - tileY);
              if (dist < minDist) {
                minDist = dist;
                bestCell = cell;
              }
            }
            
            if (bestCell && bestCell.path.length > 0) {
              nimCurrentPathRef.current = bestCell.path;
              nimPathProgressRef.current = 0;
              setNimPath(bestCell.path.flatMap((jump: any): PathStep[] => {
                if (!jump.landing) return [];
                return [
                  { node: { x: jump.start.x, y: jump.start.y, gravity: jump.start.gravity as GravityDir }, action: 'start' },
                  { node: { x: jump.landing.x, y: jump.landing.y, gravity: jump.landing.gravity as GravityDir }, action: 'jump' }
                ];
              }));
              console.log(`[Nim AI] Path to (${tileX}, ${tileY}): ${bestCell.path.length} actions`);
            } else {
              console.log(`[Nim AI] No path to (${tileX}, ${tileY})`);
            }
          }
        }}
      >
        {/* Tile container with pixel-snapped offset for smooth scrolling */}
        <div style={{
          position: "absolute",
          transform: `translate(${-Math.floor((viewX % 1) * TILE)}px, ${-Math.floor((viewY % 1) * TILE)}px)`,
        }}>
          {/* Render visible cells */}
          {visibleGrid.map((row, vy) => (
            row.map((cell, vx) => (
              <div
                key={`${vx}-${vy}`}
                style={{
                  position: "absolute",
                  left: vx * TILE,
                  top: vy * TILE,
                  width: TILE,
                  height: TILE,
                  background: COLORS[cell],
                  boxSizing: "border-box",
                  border: showGrid ? "1px solid rgba(255,255,255,0.1)" : "none",
                }}
              />
            ))
          ))}
        </div>

        {/* Room labels (positioned with pixel-snapped offset) */}
        <div style={{
          position: "absolute",
          transform: `translate(${-Math.floor((viewX % 1) * TILE)}px, ${-Math.floor((viewY % 1) * TILE)}px)`,
        }}>
          {visibleRooms.map(room => {
            const labelX = (room.x - viewXInt + room.w / 2) * TILE;
            const labelY = (room.y - viewYInt + room.h / 2) * TILE;
            if (labelX < 0 || labelX > (VIEW_W + 1) * TILE) return null;
            if (labelY < 0 || labelY > (VIEW_H + 1) * TILE) return null;
            return (
              <div
                key={room.name}
                style={{
                  position: "absolute",
                  left: labelX,
                  top: labelY,
                  transform: "translate(-50%, -50%)",
                  color: room.type === "shaft" ? "#66ffff" : "#0f0",
                  fontSize: 8,
                  opacity: 0.8,
                  textShadow: "1px 1px 2px #000",
                  whiteSpace: "nowrap",
                }}
              >
                {room.name.toUpperCase()}
              </div>
            );
          })}
        </div>
        
        {/* Path visualization */}
        {showPaths && codexPath.length > 1 && (
          <svg
            style={{
              position: "absolute",
              left: -Math.floor(viewX) * TILE,
              top: -Math.floor(viewY) * TILE,
              width: SHIP_W * TILE,
              height: SHIP_H * TILE,
              pointerEvents: "none",
              zIndex: 5,
            }}
          >
            {/* Codex path (orange) */}
            <polyline
              points={codexPath.map(step => 
                `${step.node.x * TILE + TILE/2},${step.node.y * TILE + TILE/2}`
              ).join(" ")}
              fill="none"
              stroke="#fb923c"
              strokeWidth="3"
              strokeOpacity="0.7"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeDasharray="8,4"
            />
            {/* Path nodes */}
            {codexPath.map((step, i) => (
              <circle
                key={i}
                cx={step.node.x * TILE + TILE/2}
                cy={step.node.y * TILE + TILE/2}
                r={i === 0 ? 6 : 4}
                fill={step.action === "jump" ? "#ff6b6b" : step.action === "fall" ? "#fbbf24" : "#fb923c"}
                opacity="0.8"
              />
            ))}
          </svg>
        )}
        
        {/* Physics-based jump trajectories */}
        {showPhysicsPaths && (
          <svg
            style={{
              position: "absolute",
              left: -Math.floor(viewX) * TILE,
              top: -Math.floor(viewY) * TILE,
              width: SHIP_W * TILE,
              height: SHIP_H * TILE,
              pointerEvents: "none",
              zIndex: 6,
            }}
          >
            {physicsTrajectories.map((traj, i) => (
              traj.trajectory.length > 1 && (
                <g key={i}>
                  <polyline
                    points={traj.trajectory.map(p => `${p.x},${p.y}`).join(" ")}
                    fill="none"
                    stroke="#0f0"
                    strokeWidth="2"
                    strokeOpacity="0.5"
                  />
                  {traj.landing && (
                    <circle
                      cx={traj.landing.x * TILE + TILE/2}
                      cy={traj.landing.y * TILE + TILE/2}
                      r={4}
                      fill="#0f0"
                      opacity="0.8"
                    />
                  )}
                </g>
              )
            ))}
          </svg>
        )}
        
        {/* Debug: Path segment viability */}
        {showPaths && codexPathSegments.length > 0 && (
          <div style={{
            position: "absolute",
            right: 8,
            top: 8,
            zIndex: 50,
            maxWidth: 420,
            maxHeight: 220,
            overflow: "auto",
            background: "rgba(0,0,0,0.75)",
            border: "1px solid rgba(0,240,255,0.4)",
            padding: 8,
            fontSize: 10,
            color: "#c7f9ff",
            fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace",
            pointerEvents: "none",
          }}>
            <div style={{ color: "#00f0ff", marginBottom: 6 }}>Codex path segments</div>
            {codexPathSegments.slice(0, 40).map((s: any, i: number) => (
              <div key={i} style={{
                color: s.viability === "invalid" ? "#ff6b6b" : "#c7f9ff",
                opacity: 0.95,
                marginBottom: 2,
              }}>
                {String(i).padStart(2, "0")} {s.type ?? s.action} ({s.from.x},{s.from.y},{s.from.gravity},{s.from.jumpPhase ?? 0})  ({s.to.x},{s.to.y},{s.to.gravity},{s.to.jumpPhase ?? 0})
                {s.viability === "invalid" && s.reason ? `  ${s.reason}` : ""}
              </div>
            ))}
          </div>
        )}

        {/* Debug: Tile position visualization */}
        {showPaths && (
          <svg
            style={{
              position: "absolute",
              left: -Math.floor(viewX) * TILE,
              top: -Math.floor(viewY) * TILE,
              width: SHIP_W * TILE,
              height: SHIP_H * TILE,
              pointerEvents: "none",
              zIndex: 6,
            }}
          >
            {/* Nimbus tile box (green) */}
            {debugTiles.nimbus && (
              <>
                {/* Standing tile (dashed) */}
                <rect
                  x={debugTiles.nimbus.x * TILE}
                  y={debugTiles.nimbus.y * TILE}
                  width={TILE}
                  height={TILE}
                  fill="rgba(74, 222, 128, 0.1)"
                  stroke="#4ade80"
                  strokeWidth="2"
                  strokeDasharray="4,2"
                />
                {/* Floor tile that must be solid (solid outline) */}
                <rect
                  x={debugTiles.nimbus.floorX * TILE + 4}
                  y={debugTiles.nimbus.floorY * TILE + 4}
                  width={TILE - 8}
                  height={TILE - 8}
                  fill="none"
                  stroke="#4ade80"
                  strokeWidth="3"
                />
                {/* Triangle at center */}
                <polygon
                  points={`${debugTiles.nimbus.centerX},${debugTiles.nimbus.centerY - 6} ${debugTiles.nimbus.centerX - 5},${debugTiles.nimbus.centerY + 4} ${debugTiles.nimbus.centerX + 5},${debugTiles.nimbus.centerY + 4}`}
                  fill="#4ade80"
                />
                {/* Line from center to tile center */}
                <line
                  x1={debugTiles.nimbus.centerX}
                  y1={debugTiles.nimbus.centerY}
                  x2={debugTiles.nimbus.x * TILE + TILE/2}
                  y2={debugTiles.nimbus.y * TILE + TILE/2}
                  stroke="#4ade80"
                  strokeWidth="1"
                  strokeDasharray="2,2"
                />
              </>
            )}
            {/* Codex tile box (orange) */}
            {debugTiles.codex && (
              <>
                {/* Standing tile (dashed) */}
                <rect
                  x={debugTiles.codex.x * TILE}
                  y={debugTiles.codex.y * TILE}
                  width={TILE}
                  height={TILE}
                  fill="rgba(251, 146, 60, 0.1)"
                  stroke="#fb923c"
                  strokeWidth="2"
                  strokeDasharray="4,2"
                />
                {/* Floor tile that must be solid (solid outline) */}
                <rect
                  x={debugTiles.codex.floorX * TILE + 4}
                  y={debugTiles.codex.floorY * TILE + 4}
                  width={TILE - 8}
                  height={TILE - 8}
                  fill="none"
                  stroke="#fb923c"
                  strokeWidth="3"
                />
                {/* Triangle at center */}
                <polygon
                  points={`${debugTiles.codex.centerX},${debugTiles.codex.centerY - 6} ${debugTiles.codex.centerX - 5},${debugTiles.codex.centerY + 4} ${debugTiles.codex.centerX + 5},${debugTiles.codex.centerY + 4}`}
                  fill="#fb923c"
                />
                {/* Line from center to tile center */}
                <line
                  x1={debugTiles.codex.centerX}
                  y1={debugTiles.codex.centerY}
                  x2={debugTiles.codex.x * TILE + TILE/2}
                  y2={debugTiles.codex.y * TILE + TILE/2}
                  stroke="#fb923c"
                  strokeWidth="1"
                  strokeDasharray="2,2"
                />
              </>
            )}
          </svg>
        )}
        
        {/* Nimbus (player) */}
        {charVisible && (
          <canvas
            ref={charCanvasRef}
            width={48}
            height={48}
            style={{
              position: "absolute",
              left: charScreenX,
              top: charScreenY,
              imageRendering: "pixelated",
              pointerEvents: "none",
              zIndex: 10,
            }}
          />
        )}
        
        {/* Codex (AI chasing) */}
        {codexVisible && (
          <canvas
            ref={codexCanvasRef}
            width={48}
            height={48}
            style={{
              position: "absolute",
              left: codexScreenX,
              top: codexScreenY,
              imageRendering: "pixelated",
              pointerEvents: "none",
              zIndex: 10,
            }}
          />
        )}
        
        {/* Nim (Target) */}
        {nimBaked && (
          <div
            style={{
              position: "absolute",
              left: (nimPhysics.x - viewX * TILE) + getSpriteOffset(nimPhysics.gravity).x,
              top: (nimPhysics.y - viewY * TILE) + getSpriteOffset(nimPhysics.gravity).y,
              width: 48,
              height: 48,
              transform: `rotate(${nimDisplayRotation}deg) scaleX(${nimDir === "left" ? -1 : 1})`,
              imageRendering: "pixelated",
              pointerEvents: "none",
              zIndex: 10,
              backgroundImage: `url(${nimBaked.canvas.toDataURL()})`,
              backgroundPosition: `-${nimFrame * 48}px 0`,
              backgroundSize: `${nimBaked.canvas.width}px 48px`,
            }}
          />
        )}
        
        {/* Nim Destination marker */}
        {nimDestination && (
          <div
            style={{
              position: "absolute",
              left: (nimDestination.x - viewX) * TILE,
              top: (nimDestination.y - viewY) * TILE,
              width: TILE,
              height: TILE,
              border: "2px dashed #ff00aa",
              background: "rgba(255, 0, 170, 0.2)",
              pointerEvents: "none",
              zIndex: 8,
            }}
          >
            <span style={{ color: "#ff00aa", fontSize: 8, position: "absolute", top: -12 }}>DEST</span>
          </div>
        )}
        
        {/* Nim Path visualization */}
        {showPhysicsPaths && nimPath.length > 1 && (
          <svg
            style={{
              position: "absolute",
              left: -Math.floor(viewX) * TILE,
              top: -Math.floor(viewY) * TILE,
              width: SHIP_W * TILE,
              height: SHIP_H * TILE,
              pointerEvents: "none",
              zIndex: 5,
            }}
          >
            <polyline
              points={nimPath.map(step => 
                `${step.node.x * TILE + TILE/2},${step.node.y * TILE + TILE/2}`
              ).join(" ")}
              fill="none"
              stroke="#ff00aa"
              strokeWidth="3"
              strokeOpacity="0.8"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeDasharray="6,3"
            />
            {nimPath.map((step, i) => (
              <circle
                key={i}
                cx={step.node.x * TILE + TILE/2}
                cy={step.node.y * TILE + TILE/2}
                r={i === 0 ? 6 : 4}
                fill={step.action === "jump" ? "#ff1493" : "#ff00aa"}
                opacity="0.9"
              />
            ))}
          </svg>
        )}
        
        {/* JP Path visualization (REMOVED - JP is player controlled) */}
        {false && jpPath.length > 1 && (
          <svg
            style={{
              position: "absolute",
              left: -Math.floor(viewX) * TILE,
              top: -Math.floor(viewY) * TILE,
              width: SHIP_W * TILE,
              height: SHIP_H * TILE,
              pointerEvents: "none",
              zIndex: 5,
            }}
          >
            <polyline
              points={jpPath.map(step => 
                `${step.node.x * TILE + TILE/2},${step.node.y * TILE + TILE/2}`
              ).join(" ")}
              fill="none"
              stroke="#4ade80"
              strokeWidth="3"
              strokeOpacity="0.7"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeDasharray="8,4"
            />
            {jpPath.map((step, i) => (
              <circle
                key={i}
                cx={step.node.x * TILE + TILE/2}
                cy={step.node.y * TILE + TILE/2}
                r={i === 0 ? 6 : 4}
                fill={step.action === "jump" ? "#ff6b6b" : step.action === "fall" ? "#fbbf24" : "#4ade80"}
                opacity="0.8"
              />
            ))}
          </svg>
        )}
      </div>

      {/* Minimap */}
      <div style={{ marginTop: 20 }}>
        <div style={{ color: "#888", marginBottom: 8, fontSize: 8 }}>MINIMAP</div>
        <div style={{
          position: "relative",
          width: SHIP_W * 4,
          height: SHIP_H * 4,
          background: "#111",
          border: "1px solid #333",
        }}>
          {/* Mini cells */}
          {shipGrid.map((row, y) => (
            row.map((cell, x) => (
              <div
                key={`m-${x}-${y}`}
                style={{
                  position: "absolute",
                  left: x * 4,
                  top: y * 4,
                  width: 4,
                  height: 4,
                  background: COLORS[cell],
                }}
              />
            ))
          ))}
          {/* Viewport indicator */}
          <div style={{
            position: "absolute",
            left: viewX * 4,  // Use float for smooth minimap indicator
            top: viewY * 4,
            width: VIEW_W * 4,
            height: VIEW_H * 4,
            border: "1px solid #0f0",
            boxSizing: "border-box",
          }} />
          {/* Nimbus marker on minimap */}
          <div style={{
            position: "absolute",
            left: (charPhysics.x / TILE) * 4,
            top: (charPhysics.y / TILE) * 4,
            width: 6,
            height: 6,
            background: "#4ade80",
            borderRadius: "50%",
            transform: "translate(-50%, -50%)",
          }} />
          {/* Codex marker on minimap */}
          <div style={{
            position: "absolute",
            left: (codexPhysics.x / TILE) * 4,
            top: (codexPhysics.y / TILE) * 4,
            width: 6,
            height: 6,
            background: "#fb923c",
            borderRadius: "50%",
            transform: "translate(-50%, -50%)",
          }} />
          {/* Nim marker on minimap */}
          <div style={{
            position: "absolute",
            left: (nimPhysics.x / TILE) * 4,
            top: (nimPhysics.y / TILE) * 4,
            width: 6,
            height: 6,
            background: "#ff00aa",
            borderRadius: "50%",
            transform: "translate(-50%, -50%)",
          }} />
        </div>
      </div>

      {/* Legend */}
      <div style={{ marginTop: 20, display: "flex", gap: 15, flexWrap: "wrap" }}>
        {Object.entries(COLORS).map(([name, color]) => (
          <div key={name} style={{ display: "flex", alignItems: "center", gap: 6 }}>
            <div style={{
              width: 12,
              height: 12,
              background: color,
              border: "1px solid #444",
            }} />
            <span style={{ color: "#666", fontSize: 8 }}>{name}</span>
          </div>
        ))}
      </div>

      {/* Info */}
      <div style={{ marginTop: 15, color: "#666", fontSize: 8 }}>
        Ship: {SHIP_W}{SHIP_H} tiles ({SHIP_W * TILE}{SHIP_H * TILE}px) | 
        Viewport: {VIEW_W}{VIEW_H} | Tile: {TILE}px
      </div>

      {/* Debug Command Panel */}
      <div style={{ 
        marginTop: 20, 
        padding: 10, 
        background: "#1a1a2e", 
        border: "1px solid #333",
        maxWidth: 400,
      }}>
        <div style={{ color: "#0ff", fontSize: 10, marginBottom: 10 }}>
          CODEX DEBUG COMMANDS
        </div>
        <div style={{ color: "#666", fontSize: 8, marginBottom: 10 }}>
          Codex: x={Math.round(codexPhysics.x)} y={Math.round(codexPhysics.y)} | 
          gravity={codexPhysics.gravity} | grounded={codexPhysics.grounded ? "Y" : "N"}
        </div>
        
        <div style={{ display: "flex", flexWrap: "wrap", gap: 5, marginBottom: 10 }}>
          {/* Test Move Left */}
          <button
            onClick={() => {
              const startX = codexPhysics.x;
              codexInputRef.current = { ...codexInputRef.current, left: true, right: false };
              setTimeout(() => {
                codexInputRef.current = { ...codexInputRef.current, left: false };
                const endX = codexPhysics.x;
                const moved = endX < startX;
                setCommandResults(prev => [...prev.slice(-9), {
                  name: "Move Left",
                  expected: `x should decrease from ${Math.round(startX)}`,
                  actual: `x is now ${Math.round(endX)}`,
                  passed: moved,
                }]);
              }, 500);
            }}
            style={{ padding: "4px 8px", background: "#333", color: "#fff", border: "1px solid #666", cursor: "pointer", fontSize: 8 }}
          >
             Left
          </button>
          
          {/* Test Move Right */}
          <button
            onClick={() => {
              const startX = codexPhysics.x;
              codexInputRef.current = { ...codexInputRef.current, right: true, left: false };
              setTimeout(() => {
                codexInputRef.current = { ...codexInputRef.current, right: false };
                const endX = codexPhysics.x;
                const moved = endX > startX;
                setCommandResults(prev => [...prev.slice(-9), {
                  name: "Move Right",
                  expected: `x should increase from ${Math.round(startX)}`,
                  actual: `x is now ${Math.round(endX)}`,
                  passed: moved,
                }]);
              }, 500);
            }}
            style={{ padding: "4px 8px", background: "#333", color: "#fff", border: "1px solid #666", cursor: "pointer", fontSize: 8 }}
          >
             Right
          </button>
          
          {/* Test Jump */}
          <button
            onClick={() => {
              const wasGrounded = codexPhysics.grounded;
              codexInputRef.current = { ...codexInputRef.current, jump: true };
              setTimeout(() => {
                codexInputRef.current = { ...codexInputRef.current, jump: false };
                const becameAirborne = !codexPhysics.grounded || codexPhysics.vy < 0;
                setCommandResults(prev => [...prev.slice(-9), {
                  name: "Jump",
                  expected: wasGrounded ? "should become airborne" : "was already airborne",
                  actual: codexPhysics.grounded ? "still grounded" : "airborne",
                  passed: wasGrounded ? becameAirborne : true,
                }]);
              }, 200);
            }}
            style={{ padding: "4px 8px", background: "#333", color: "#fff", border: "1px solid #666", cursor: "pointer", fontSize: 8 }}
          >
             Jump
          </button>
          
          {/* Reset Position */}
          <button
            onClick={() => {
              setCodexPhysics({
                x: 13 * TILE,
                y: 5 * TILE - PLAYER.COLLIDER_SIZE,
                vx: 0,
                vy: 0,
                gravity: "DOWN",
                grounded: true,
                width: PLAYER.COLLIDER_SIZE,
                height: PLAYER.COLLIDER_SIZE,
                jumpHeld: false,
              });
              setCodexPath([]);
              setCommandResults(prev => [...prev.slice(-9), {
                name: "Reset",
                expected: "Codex at spawn position",
                actual: "Reset complete",
                passed: true,
              }]);
            }}
            style={{ padding: "4px 8px", background: "#660000", color: "#fff", border: "1px solid #f00", cursor: "pointer", fontSize: 8 }}
          >
             Reset
          </button>
          
          {/* Clear Path */}
          <button
            onClick={() => {
              setCodexPath([]);
              setCommandResults(prev => [...prev.slice(-9), {
                name: "Clear Path",
                expected: "Path cleared",
                actual: `Cleared (was ${codexPath.length} steps)`,
                passed: true,
              }]);
            }}
            style={{ padding: "4px 8px", background: "#333", color: "#fff", border: "1px solid #666", cursor: "pointer", fontSize: 8 }}
          >
             Clear Path
          </button>
        </div>
        
        {/* Test Results */}
        <div style={{ fontSize: 8 }}>
          {commandResults.map((result, i) => (
            <div 
              key={i} 
              style={{ 
                padding: "3px 5px", 
                marginBottom: 2,
                background: result.passed ? "rgba(0,255,0,0.1)" : "rgba(255,0,0,0.1)",
                borderLeft: `3px solid ${result.passed ? "#0f0" : "#f00"}`,
              }}
            >
              <div style={{ color: result.passed ? "#0f0" : "#f00" }}>
                {result.passed ? "" : ""} {result.name}
              </div>
              <div style={{ color: "#888" }}>
                Expected: {result.expected}
              </div>
              <div style={{ color: "#aaa" }}>
                Actual: {result.actual}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
